# treinando structs

## Structs

```elixir
defmodule People do
  defstruct id: nil,
            first_name: nil,
            last_name: nil, 
            birthday: nil,
            location: "home",
            date_created: nil

  def new(first_name, last_name, birthday, location \\ "home") do
    %People{
      id: :erlang.unique_integer([:positive]),
      first_name: first_name,
      last_name: last_name,
      birthday: birthday,
      date_created: DateTime.utc_now(),
      location: location
    }
  end

  def full_name(%__MODULE__{} = person) do
    "#{person.first_name} #{person.last_name}"
  end

  def age(%__MODULE__{} = person) do
    days = Date.diff(Date.utc_today(), person.birthday)
    days / 365.25
  end

  def toggle_location(%__MODULE__{location: "away"} = person) do
    person |> set_location("home")
  end

  defp set_location(%__MODULE__{} = person, location) do
    %{person | location: location}
  end
  
end
```

```elixir
person = %People{first_name: "Bruce", last_name: "Wayne", birthday: ~D[2000-01-01], location: "away"}
```

```elixir
people = People.new("Test", "testing", ~D[2000-01-01])
```

```elixir
People.full_name(people)
```

```elixir
People.age(people)
```

```elixir
People.toggle_location(person)
```

```elixir
defmodule Todo do
  defstruct id: nil, title: "", completed: false, date_created: DateTime.utc_now(), date_update: nil  
end
```

```elixir
ExUnit.start()
```

```elixir
defmodule TodoList do
  def start do
    []
  end

  def add_todo(todos, title) do
    id = Enum.count(todos) + 1
    new_todo = %Todo{id: id, title: title}
    [new_todo | todos]
  end

  def list_todos(todos) do
    Enum.each(todos, fn todo -> 
      IO.puts("ID: #{todo.id} - #{todo.title} [#{if todo.completed, do: "X", else: " "}]")
      end)
  end

  def completed_todo(todos, id) do
    Enum.map(todos, fn todo -> 
      if todo.id == id do
        %{todo | completed: true, date_update: DateTime.utc_now()}
      else
        todo
      end
      end)
  end

  def remove_todo(todos, id) do
    Enum.reject(todos, fn todo -> todo.id == id end)
  end
end
```

```elixir
defmodule TodoTest do
  use ExUnit.Case
  
  test "Given title, when add todo, then return a new todo list" do
    todos = TodoList.start()
    todos = TodoList.add_todo(todos, "Jonh doe")
    assert length(todos) == 1
  end
end
```

```elixir
ExUnit.run()
```

```elixir
todos = TodoList.start()
```

```elixir
todos = TodoList.add_todo(todos, "Estudar elixir")
todos = TodoList.add_todo(todos, "Escrever artigo")
todos = TodoList.add_todo(todos, "Fazer exercício")
```

```elixir
TodoList.list_todos(todos)
```

```elixir
todos = TodoList.completed_todo(todos, 1)
```

```elixir
TodoList.list_todos(todos)
```

```elixir
todos = TodoList.remove_todo(todos, 1)
```

```elixir
TodoList.list_todos(todos)
```

```elixir
defmodule Produto do
  defstruct nome: nil, valor: 1.99
end
```

```elixir
sabone = %Produto{nome: "Dove"}
```

```elixir
shampoo = %Produto{nome: "Nivia", valor: 5.50}
```

## Documentação

```elixir
defmodule Student do
  @moduledoc """
    Define a Student struct and functions to handle a student
  """
  defstruct name: nil, results: []

  @doc """
    * Get the first name of a Student.
    * joao = %Student{name: "João Joaquim"}
    * Student.first_name(joao)
    * "João"
  """
  def first_name(student) do
    student.name
    |> String.split
    |> List.first
  end

  @doc """
    * Get the last name of a Student.
    * joao = %Student{name: "João Joaquim"}
    * Student.last_name(joao)
    * "Joaquim"
  """
  def last_name(student) do
    student.name
    |> String.split
    |> List.last
  end
end
```

```elixir
defmodule Subject do
  defstruct name: nil, result: nil
end
```

```elixir
defmodule Calculator do
  def start() do
    joao = %Student{name: "João Joaquim", results: build_subjects([5.2, 3.9, 2.7, 9.8])}
    maria = %Student{name: "Maria da Silva", results: build_subjects([8.4, 7.5, 9.4, 2.8])}
    pedro = %Student{name: "Pedro Pedrada", results: build_subjects([1.3, 8.5, 8.9, 7.6])}
    kaua = %Student{name: "Kauã Camboinhas", results: build_subjects([5.4, 4.9, 2.2, 3.8])}

    result = calculate([joao, maria, pedro, kaua])
    best = best_result(result)

    {result, best}
  end

  defp calculate(students) do
    students
    |> Enum.map(&(
      %{
        first_name: Student.first_name(&1),
        last_name: Student.last_name(&1),
        average: average(&1)
      }
    ))
  end

  defp average(student) do
    total = Enum.count(student.results)

    result = student.results
    |> Enum.map(&(&1.result))
    |> Enum.reduce(&(&1 + &2))

    Float.ceil(result / total, 2)
  end

  defp best_result(students) do
    best = students
    |> Enum.map(&(&1.average))
    |> Enum.max

    students
    |> Enum.filter(&(&1.average == best))
  end

  defp build_subjects(results) do
    subjects = ["Matemática", "Português", "Geografia", "História"]

    subjects
    |> Enum.map(&(%Subject{name: &1, result: Enum.random(results)}))
  end
end
```

```elixir
{result, best} = Calculator.start()
```

```elixir
result
```

```elixir
best
```
